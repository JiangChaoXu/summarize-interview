(1)事件委托
<ul id="ul">
	<li>aaaaaaaa</li>
	<li>bbbbbbbb</li>
	<li>cccccccc</li>
</ul>
window.onload = function(){
	var oUl = document.getElementById("ul");
	var aLi = oUl.getElementsByTagName("li");
/*
这里要用到事件源：event 对象，事件源，不管在哪个事件中，只要你操作的那个元素就是事件源。
ie：window.event.srcElement
标准下:event.target
nodeName:找到元素的标签名
*/
	oUl.onmouseover = function(ev){
		var ev = ev || window.event;
		var target = ev.target || ev.srcElement;
		//alert(target.innerHTML);
		if(target.nodeName.toLowerCase() == "li"){
		target.style.background = "red";
		}
	}

(2)css 伪类元素使用顺序 //love hate
link visit hover active

(3)css选择器的权重与优先级
权重1000	内联样式表                	     style=""  	      
权重100 	ID选择器			      id
权重10  	类，伪类和属性选择器	     class	     	
权重1   	类型选择器和微元素选择器    div p

发散:层叠样式表的层叠代表什么意思
层叠代表了样式的优先级，产生冲突时以优先级高的为准
权重相同时取后面定义的样式
带有上下文关系的选择器比单纯的选择器权重要高

(4)媒体查询
@media mediatype and|not|only (media feature) {
    CSS-Code;
}
@media screen and (max-device-width:960px)
{background:red;}
}
<!--满足条件时，使用mystylesheet.css文件-->
<link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css">

(5)常用的块级元素和内联元素
块级:<div> <h1> <form> <ol> <ul> <p> <table>
内联:<a> <span> <img> <big> <textarea><input>
可变元素:<button>

(6)css属性overflow属性定义溢出元素内容区的内容会如何处理。
参数是scroll时候，必会出现滚动条。
参数是auto时候，子元素内容大于父元素时出现滚动条。
参数是visible时候，溢出的内容出现在父元素之外。
参数是hidden时候，溢出隐藏。

(7)Difference of RGBA and Opacity
opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性。

(8)link和@import的区别
区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。
区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。
区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。
区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。

(9)src和href的区别
src是物件的来源地址，是引入的感觉。
href是一种链接前往，是引用的的感觉。

(10)css中clear的作用是什么？
对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。

(11)为什么要初始化CSS样式
因为浏览器的兼容性，因为每个浏览设计时都有自己的特性，没有统一的规定，所以对于某些标签是不同的，不进行浏览器初始化，则会造成浏览器显示页面有微小的差异

(12)浏览器兼容问题
IE6 双边距 bug：在 IE6 下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。
#box{ float:left; width:10px; margin:0 0 0 10px;} 
这种情况之下 IE6 会产生20px的距离
解决方案：在float的标签样式控制中加入 _display:inline; 将其转化为行内属性。

 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 

浏览器默认的margin和padding不同
解决方案：加一个全局的 *{margin:0;padding:0;} 来统一。

(13)浮动元素引起的问题和解决办法？
1. 父元素的高度无法被撑开，影响与父元素同级的元素
2. 与浮动元素同级的非浮动元素会跟随其后
3. 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

额外标签法，<div style="clear:both;"></div>
#parent:after{
    content:".";
    height:0;
    visibility:hidden;
    display:block;
    clear:both;
}
设置 overflow 为 hidden 或者 auto

(14)http状态码有那些？分别代表是什么意思？
1xx: 信息性状态码，表示服务器接收到请求正在处理。
2xx: 成功状态码，表示服务器正确处理完请求。
3xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。301永久重定向，302临时重定向。
4xx: 客户端错误状态码，服务器无法处理该请求。 404 not found 5xx: 服务器错误状态码，服务器处理请求出错。

(15)请写一个表格以及对应的CSS，使表格奇数行为白色背景，偶数行为灰色背景，鼠标移上去时为黄色背景
<style>
  .table tr:nth-child(odd){
      background-color:white;
  }
  .table tr:nth-child(even){
      background-color:gray;
  }
  .table tr:hover{
      background-color:yellow;
  }
</style>

(16)target的值：_blank         在新窗口打开链接
                           _self            在当前框架中打开链接
                           _parent       在父框架打开链接
                           _top             在当前窗口打开链接
                   	     framename  在指定框架打开链接

(17)H5新标签
<article>  <aside>  <audio> <canvas> <footer> <hgroup> <mark> <nav> <source>

(18)背景色彩和文字色彩的HTML代码如下。
bgcolol——背景色彩
text——非可链接文字的色彩
link——可链接文字的色彩
alink——正被点击的可链接文字的色彩
vlink——已经点击(访问)过的可链接文字的色彩

(19)表单元素，设置表单提交方式和路径的属性为method和action.

(20)css3 有哪些新特性
CSS3实现圆角（border-radius），阴影（box-shadow）， 
   对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） 
   在CSS3中唯一引入的伪元素是::selection. //使被选中文本变红
  媒体查询，多栏布局 

  (21)CSS中可以和不可以继承的属性
  Bd 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-bread-before和unicode-bidi。 
  所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 终端块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。

  (22)动画实现方案，并对比说明各自特点。
  css3旋转，transform, transition, animate

  (23)rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。

  (24)要使页面的 <a> 标签中，文字超出 80 像素的部分显示为 .....
  display:block；
overflow:hidden;
white-space:nowrap;//文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。
text-overflow:ellipsis;//	显示省略符号来代表被修剪的文本。

(25)input 的 type 属性值列举 3 个
text password radio checkbox button reset submit

(26)AMD 和 CMD 的区别有哪些？
AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。
2. CMD 推崇依赖就近，AMD 推崇依赖前置

(27)new操作符具体干了什么呢?
1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型
2. 属性和方法被加入到 this 引用的对象中
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj); 



(28).函数声明和函数表达式之间的区别
(1)函数声明必须有标识符，也就是常说的函数名；函数表达式可以省略函数名。
(2)函数声明是在浏览器准备执行代码的时候执行的。
（记住变量提升，函数声明感觉有点像）
(3)ECMAScript规范中表示，函数声明语句可以出现在全局代码中，或者内嵌在其他函数中，但是不能出现在循环、条件判、或者try/finally以及with语句中。
(4)可以创建一个函数表达式即刻执行。
(function(){
alert('博主的名字是：myvin 。');
})()

(29)减少页面加载时间的方法


(30)实现水平垂直居中
   position: absolute;
        width:100px;
        height: 50px;
        top:50%;
        left:50%;
        margin-left:-50px;
        margin-top:-25px;
        text-align: center;

         position: absolute;
            top:50%;
            left:50%;
            width:100%;
            transform:translate(-50%,-50%);
            text-align: center;

            display: flex;
           justify-content: center;
           align-items: center;

           display:table-cell; //让元素渲染成表格单元格
  	width:300px; height:300px; 
  	text-align:center; vertical-align:middle;



(31)函数声明和函数表达式之间的区别
(1)函数声明必须有标识符，也就是常说的函数名；函数表达式可以省略函数名。
(2)函数声明是在浏览器准备执行代码的时候执行的。
（记住变量提升，函数声明感觉有点像）
(3)ECMAScript规范中表示，函数声明语句可以出现在全局代码中，或者内嵌在其他函数中，但是不能出现在循环、条件判、或者try/finally以及with语句中。
(4)可以创建一个函数表达式即刻执行。
(function(){
alert('博主的名字是：myvin 。');
})()



(32).cookie和session. Local storage


(33)同源策略与跨域(https://earthsplitter.github.io/2017/03/21/%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/)

协议，端口，域名 完全相同

非ajax请求:
1.document.domain
对于只有前缀(二级、三级等域名)不同的网页，可以设置 document.domian 来规避同源策略.具有相同domain的可以互相读取Cookie.

2.fragment identifer
改变url #后边的data 。父窗口可以操作dom改变子窗口src，反之亦然

3.window.name
name是window一个属性，无论window的内容如何变化，他不变
利用iframe，在iframe中指向跨域网站，检测到onload后取回

4.window.postMessage
H5新出的，用于跨域父子窗口通讯，不受同源策略限制
popup.postMessage('Hello World!', 'http://bbb.com');
//子窗口向父窗口发送消息


ajax请求
1.websocket
不实行同源策略
2.JSONP
优势在于兼容低级别浏览器，但是只能GET
其设计思路是因为浏览器不对 <script> 标签进行限制，因此可以利用这一点来进行跨域请求。
声明一个回调函数，其参数为要获取(服务器提供的data)，对参数进行操作(比如渲染进DOM)
create一个<script>标签动态加入DOM tree，在src的URL中向服务器传递该函数名
服务器返回一个js脚本文件，将数据包括在url中给的回调函数里，运行回调函数
3.CORS(cross origin resource sharing)
无法兼容低级别浏览器
分为简单请求(GET,POST,HEAD)和非简单请求
在请求头加入origin字段指定源。然后还有其他三个字段
非简单请求，origin还有其他字段，问两次，第一次预检，之后和普通cors一样


(34)请解释 <script>、<script async> 和 <script defer> 的区别。

(35)ES6新特性
箭头函数，类，字符串模板，let const，for of ，genertator，模块，Map Set，Promise

(36)即时通讯消息的几种方式

轮询:定时像ajax发送请求       适用于小型应用
优点：后端程序编写比较容易。 
缺点：请求中有大半是无用，浪费带宽和服务器资源。 

长轮询：客户端像服务端发ajax请求，服务器服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 
优点：在无消息的情况下不会频繁的请求，耗费资小。 
缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。

长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断地往客户端输入数据。 
优点：消息即时到达，不发无用请求；管理起来也相对便。 
缺点：服务器维护一个长连接会增加开销。 

WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。
特点:
a、事件驱动
b、异步
c、使用 ws 或者 wss 协议的客户端 socket
d、能够实现真正意义上的推送功能

之前的都要主动拉，websocket是双方互相推送

(37)react的优势、diff算法的理解、为什么要单向数据流、组件交互。prop和state的区别

优势:功能组件化，遵守前端的可维护原则

https://zhuanlan.zhihu.com/p/20346379?refer=purerender
diff算法:
传统diff算法 ，remove，add，change挨个遍历每个节点，复杂度为n3

reactdiff算法:
把复杂度降低为n。
1.DOM节点跨层级少  tree diff 
如果节点不存在，直接删除，不会进一步去其它层比较
2.比较组件，不同组件基本不同DOM  component diff
不同类型的组件，存在相似DOM树的机会不多。所以不同组件比较出不同就直接删
3.同一层级的子节点通过id区分 element diff
插入，移动，删除三个操作。

React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；
React 通过分层求异的策略，对 tree diff 进行算法优化；
React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；
React 通过设置唯一 key的策略，对 element diff 进行算法优化；
建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；
建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。

单向数据流
实现了真正的数据驱动，以数据为核心

props和state的区别:(有点像public和private)
state只能存在于组件内部。props当做数据源，state用来存放状态信息


(38)jq里边load和ready的区别
按加载时间来说。load等所有元素加载完成(图片，渲染)，ready等dom树加载完成就行。
按数量来说，load只能使用一次，后边的会覆盖之前的，ready可以重复使用


(39)http
 增删改查
POST DELETE PUT GET



 (40)闭包的优点缺点
优点：
1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。
2. 方便调用上下文的局部变量。
3. 加强封装性，第2点的延伸，可以达到对变量的保护作用。
缺点：
闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生

函数和函数内部能访问到的变量的总和就是闭包。
目的:隐藏变量(间接访问一个变量)
问题:一直不释放变量，造成资源浪费

闭包的场景：
1.使用闭包可以在JavaScript中模拟块级作用域；
2.闭包可以用于在对象中创建私有变量。


(41)cookie和session的区别
cookie存于客户端。
session存于服务器端。
服务器鉴别session需要至少从客户端传来一个session_id，session_id通常存于cookie中，或是url（很少用url，主要涉及安全性和SEO的影响）
所以在工程上session离了cookie基本没法用，但是cookie可以单独使用，不过cookies是明文存储，安全性很低，只使用cookie的话盗取了cookie基本就获取了用户所有权限。
另外浏览器每次访问网页都会带上cookie，如果cookie存储内容过多，会严重占用服务器端带宽，影响性能。
所以如果你是简单或且安全不敏感的应用，可以只使用cookie。否则还是需要cookie配合session。
不过现有语言和框架基本都可以让你简单地使用session，而无需考虑session和cookie的关系。

(42).localstorage，sessionstorage（合起来叫webstorage）
HTML5 提供了两种在客户端存储数据的新方法：
localStorage - 没有时间限制的数据存储
sessionStorage - 针对一个 session 的数据存储
之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。
在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。
对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。
HTML5 使用 JavaScript 来存储和访问数据.
localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。
sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。
都会在浏览器端保存，有大小限制，同源限制
cookie会在请求时发送到服务器，作为会话标识，服务器可修改cookie；web storage不会发送到服务器
cookie有path概念，子路径可以访问父路径cookie，父路径不能访问子路径cookie
有效期：cookie在设置的有效期内有效，默认为浏览器关闭；sessionStorage在窗口关闭前有效，localStorage长期有效，直到用户删除
共享：sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享
localStorage的修改会促发其他文档窗口的update事件
cookie有secure属性要求HTTPS传输
浏览器不能保存超过300个cookie，单个服务器不能超过20个，每个cookie不能超过4k。web storage大小支持能达到5M


(43).1+'1'='11'
'1'+1='11'
1+1+'1'='21'
1+'1'+1='111'
如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。
如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。
如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。
如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。
在比较时，该运算符还遵守下列规则：
值 null 和 undefined 相等。
在检查相等性时，不能把 null 和 undefined 转换成其他值。
如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。
如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。

(44).[]==true //false
[]==[] //false
[]=={}//false
([])//true
[]==false//true
{}==false//false
null==undefined//true

(45).数组去重
var a=[1,1,3,3,3,5];
(1).var b=new Set(a);
var res=[];
for(var c of b){
res.push(c);
}

(2).var res=[];
for(var i=0;i<a.length;i++){
if(res.indexOf(a[i])==-1){
   res.push(a[i]);
  }
}

(3).需要排序的时候，先排序，然后相邻的一样就删除

(4).for(var i=a.length-1;i>=0;i--){
if(a.indexOf(a[i])==i){
   res.push(a[i]);
  }
}

(5)res=a.filter(function(element,index,self){
     return self.indexOf(element)===index;
});


(46)for...in出来的是index，for....of 出来的是value，不过of好像没法遍历对象


(47)javascript有哪些方法定义对象
1对象字面量： var obj = {};
2构造函数：Object(){}
 var obj = new Object();//== var obj =new Object()  obj=Object
3Object.create(): 
var obj = Object.create(Object.prototype);

(48)js中arguments是对象，不是数组。转数组。
function fn(){
  var arr=Array.prototype.slice.call(arguments,0);
}

(49)区分数组和对象
instanceOf
Object.prototype.toString.call(a)==='[Object Array]'


(50)js原型链
prototype与_proto_的关系
        ①prototype是构造函数的属性
        ②_proto_是实例对象的属性


(51)gulp webpack底层实现


(52)js基本数据类型(没有Array)
string number boolean null undefined Symbol



(53)css3伪类和伪元素



(54)XSS CSRF
Cross SiteScript
http://blog.csdn.net/ghsau/article/details/17027893
http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html

(55)哪些操作会造成内存泄漏
内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

1. setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
2. 闭包
3. 控制台日志
4. 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

(56)如何判断当前脚本运行在浏览器还是node环境中？
看全局变量。node的全局变量时global，而浏览器时window

(57)js的同源策略
概念：
同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。
这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。

为什么要有同源限制：
我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。

（58）eval是做什么的
1. 它的功能是把对应的字符串解析成JS代码并运行
2. 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）

(59)用promise手写ajax
 function get(){
    $.ajax({
    url:'test.php'
    }).then(function(){
    return $.ajax({url:'test1.php'});
    })
 }

(60)手写一个类的继承，并解释一下。new对象的过程发生了什么
function Student(name){
    this.name=name;
}

Student.prototype.hello=function(){
    console.log('say hello');
}

var xiaoming = new Student('xiaoming');


ES6:
class Student{
    constructor(name){
    this.name = name;
    }

    hello(){
     alert('Hello' + this.name)
    }
}

var xiaoming = new Studeng('xiaoming');

class PriStudent extends Student{
    constructor(name,grade){
    super(name);
    this.grade = grade;
    }

    myGrade(){
    alert(this.grade);
    }
}


在 JavaScript 中，使用 new 关键字后，意味着做了如下四件事情：
创建一个新的对象，这个对象的类型是 object；
设置这个新的对象的内部、可访问性和[[prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的；
执行构造函数，当this关键字被提及的时候，使用新创建的对象的属性； 返回新创建的对象（除非构造方法中返回的是‘无原型’）。
在创建新对象成功之后，如果调用一个新对象没有的属性的时候，JavaScript 会延原型链向止逐层查找对应的内容。这类似于传统的‘类继承’。
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);


(61)对闭包的理解，实现一个暴露内部变量，而且外部可以访问修改的函数（get和set，闭包实现）
function f1(){
    var n=1;
    nAdd = function(){n+=1;}
    function f2(){
    alert(n);
    }
    return f2;
}

var result =f1();
result();
nAdd();
result();


(62)transition animation 的区别

transition是两针的，设置开头结尾。animation是很多帧的
不同点：

1.  触发条件不同。transition通常和hover等事件配合使用，由事件触发。animation则和gif动态图差不多，立即播放。

2. 循环。 animation可以设定循环次数。

3. 精确性。 animation可以设定每一帧的样式和时间。tranistion 只能设定头尾。 animation中可以设置每一帧需要单独变化的样式属性， transition中所有样式属性都要一起变化。

4. 与JavaScript的交互。animation与js的交互不是很紧密。tranistion和js的结合更强大。js设定要变化的样式，transition负责动画效果，天作之合，比之前只能用js时爽太多。

结论：

1. 如果要灵活定制多个帧以及循环，用animation.

2. 如果要简单的from to 效果，用 transition.

3. 如果要使用js灵活设定动画属性，用transition.


(63)AMD和CMD


(64)检验json变化

(65)队列、堆、栈、堆栈的区别？
队列是先进先出：就像一条路，有一个入口和一个出口，先进去的就可以先出去。
而栈就像一个箱子，后放的在上边，所以后进先出。
栈(Stack)是操作系统在建立某个进程时或者线程
堆（Heap)是应用程序在运行的时候请求操作系统分配给自己内存

(66)SEO


(67)低版本浏览器不支持HTML5标签怎么解决？
引入js，js中有解析的代码
<!--[if IE]><script src="style/js/html5.js"></script><![endif]-->

在html中直接插入
for(var i=0; i<tags.length; i++)document.createElement(tags[i]);})(["article","aside","details","figcaption","figure","footer","header","hgroup","nav","section","menu","video"]);</script>
通过插入dom节点相应的标签让他认识

(68)圣杯布局  http://www.jianshu.com/p/f9bcddb0e8b4
写结构的时候要注意，父元素的的三栏务必先写中间盒子。因为中间盒子是要被优先渲染嘛~并且设置其自适应，也就是width:100%。写结构的时候要注意，父元素的的三栏务必先写中间盒子。因为中间盒子是要被优先渲染嘛~并且设置其自适应，也就是width:100%。
具体结果见test

(69)内置的方法
Array
indexOf slice push pop shift unshift splice sort reverse concat join

String
substring(start,end) indexOf charAt substr(start,length) search(reExp) concat split toLowerCase

Object
constructor hasOwnProperty  toString([Object Object])  valueOf(return Object)

(70)浏览器内置对象
Window      Window 对象表示浏览器中打开的窗口
Navigator   Navigator 对象包含有关浏览器的信息  版本 语言 系统 运行平台
Screen      Screen 对象包含有关客户端显示屏幕的信息。  屏幕高度 亮度 分辨率
History     History 对象包含用户（在浏览器窗口中）访问过的 URL。
Location    Location 对象包含有关当前 URL 的信息。 域名 端口 主机


(71)


(72)


(73)


(74)


(75)


(76)


(77)



(78)


(79)

(80)



